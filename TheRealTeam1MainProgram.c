#pragma config(Sensor, in1,    Gyroscope,      sensorGyro)
#pragma config(Sensor, in2,    RightLiftSensor, sensorPotentiometer)
#pragma config(Sensor, in3,    LeftLiftSensor, sensorPotentiometer)
#pragma config(Sensor, in4,    FourBarSensor,  sensorPotentiometer)
#pragma config(Sensor, in5,    MogoSensor,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightshaft,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftshaft,      sensorQuadEncoder)
#pragma config(Motor,  port1,           ConeIntake,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightbackwheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightfrontwheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           FourBar,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LeftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftbackwheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftfrontwheel, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#include "slew motor program.c"
#include "LCD_Control.c"
#define DEADBAND 20





const int MAX_SCISSORHEIGHT = 2000; // This is maximum change in potentiometer value
const int MIN_SCISSORHEIGHT = 0;
const int MAX_FOURBARHEIGHT = 4000;
const int MIN_FOURBARHEIGHT = 0;

const float SLEW_OFFSET = .8;
const int MAXPOWER = 90;
const int TURN_MAXPOWER = 80;
const float P_FACTOR = .2;
const int WAIT_FOR_STOP = 200;
int Scissortarget = 0;
int FourBarTarget = 0;
bool ScissorLiftControl = false;
bool FourControl = false;
int min(int a, int b) {
	if (a > b)
		return b;
	return a;
}

int max(int a, int b) {
	if (a > b)
		return a;
	return b;
}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
//	LCD();
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task FourBarControl()
{
	int FourBarError = 0; // Distance away from target, sets the value
	int FourBarSpeed = 0; //How fast four bar motor is moving
	while(true)
	{
		if(FourControl)
		{
			// Making sure nothing goes over the limit
			if (FourBarTarget > MAX_FOURBARHEIGHT)
			{
				FourBarTarget = MAX_FOURBARHEIGHT;
			}
			if (FourBarTarget < MIN_FOURBARHEIGHT)
			{
				FourBarTarget = MIN_FOURBARHEIGHT;
			}
			// Setting what our current value is
			int CurrentFourBarValue = SensorValue[FourBarSensor];
			// Setting out Error (Current value - Target value)
			FourBarError = FourBarTarget - CurrentFourBarValue;
			// Setting speed to the error
			FourBarSpeed = FourBarError;

			if (FourBarSpeed > 127) // Motor Shall not pass max speed
			{
				FourBarSpeed = 127;
			}
			else if (FourBarSpeed < -127) // Motor Shall not pass max speed
			{
				FourBarSpeed = -127;
			}
			else if (abs(FourBarSpeed) < 20) //Keep motor from making stalling sound
			{
				FourBarSpeed = 0;
			}
		}
		motorReq[FourBar] = FourBarSpeed;
	}
}
task ScissorControl()
{
	int scissorLeftInitValue = SensorValue[LeftLiftSensor]; // Scissor height will be an offset from these values
	int scissorRightInitValue = SensorValue[RightLiftSensor];
	int ScissorErrorRight = 0;
  int ScissorErrorLeft = 0;
  int ScissorLiftLeft = 0;
  int ScissorLiftRight = 0;
  int buffer = 100;

	while (true) {
		if(ScissorLiftControl)
		{
			// Potentiometer values decrease with height, so we subtract target height from the initial value
		  //  to get target potentiometer value
			int lefttarget = scissorLeftInitValue - Scissortarget;
			int righttarget = scissorRightInitValue - Scissortarget - 150;

			if (Scissortarget > MAX_SCISSORHEIGHT)
			{
				Scissortarget = MAX_SCISSORHEIGHT;
			}
			if(Scissortarget < MIN_SCISSORHEIGHT)
			{
				Scissortarget = MIN_SCISSORHEIGHT;
			}
			int currentvalueRight = SensorValue[RightLiftSensor];
			ScissorErrorRight = righttarget - currentvalueRight;
			ScissorLiftRight = ScissorErrorRight/2;
			if (ScissorLiftRight > 127) {
				ScissorLiftRight = 127;
			}
			else if (ScissorLiftRight < -127)
			{
				ScissorLiftRight = -127;
			}
			else if (abs(ScissorLiftRight) < 20)
				ScissorLiftRight = 0;


		int currentvalueLeft = SensorValue[LeftLiftSensor];
		ScissorErrorLeft = lefttarget - abs(currentvalueLeft);
		ScissorLiftLeft = ScissorErrorLeft/2;
					if (ScissorLiftLeft > 127) {
				ScissorLiftLeft = 127;
			}
			else if (ScissorLiftLeft < -127)
			{
				ScissorLiftLeft = -127;
			}
			else if (abs(ScissorLiftLeft) < 25)
				ScissorLiftLeft = 0;



		//Sensors Moving to fast
	/*			if (abs(SensorValue[LeftLiftSensor]) > abs(SensorValue[RightLiftSensor]) + buffer)
				{
					ScissorLiftLeft -= 5;
				}
				else if (abs(SensorValue[LeftLiftSensor]) < abs(SensorValue[RightLiftSensor]) + buffer)
			{
				ScissorLiftLeft += 5;
			}
			// Right Sensor moving too fast
			if (abs(SensorValue[RightLiftSensor]) > abs(SensorValue[LeftLiftSensor]) + buffer)
			{
				ScissorLiftRight -= 5;
			}
			if (abs(SensorValue[RightLiftSensor}) < abs(SensorValue[LeftLiftSensor]) + buffer)
			{
			ScissorLiftRight += 5;
			}
*/
//			if (Scissortarget == MIN_SCISSORHEIGHT) { // Turn off motors if we need min height
//				motorReq[RightLift] = 0;
//				motorReq[LeftLift] = 0;
//			} else {
				motorReq[RightLift] = -ScissorLiftRight; // Negative sign since pot values decrease with height
				motorReq[LeftLift] = -ScissorLiftLeft;
//			}
		}
		wait1Msec(MOTOR_TASK_DELAY);
	}
}


	void moveforward_right(int forward) {

	motor[rightfrontwheel] = forward;
	motor[rightbackwheel] = forward;
}
void moveforward_left(int forward) {
	motor[leftfrontwheel] = forward;
	motor[leftbackwheel] = forward;
}
void moveforward(int forward) {
	moveforward_left(forward);
	moveforward_right(forward);
}
void movebackward_left(int backward) {
	motor[leftfrontwheel] = -backward;
	motor[leftbackwheel] = -backward;
}
void movebackward_right(int backward) {
	motor[rightfrontwheel] = backward;
	motor[rightbackwheel] = backward;
}
void movebackward(int backward) {
	movebackward_right(backward);
	movebackward_left(backward);
}
void turnleft_left(int left) {
	motor[leftfrontwheel] = -left;
	motor[leftbackwheel] = -left;
}
void turnleft_right(int left) {
	motor[rightfrontwheel] = -left;
	motor[rightbackwheel] = -left;
}
void turnleft(int left) {
	turnleft_right(left);
	turnleft_left(left);
}
void turnright_left(int right) {
	motor[leftfrontwheel] = right;
	motor[leftbackwheel] = right;
}
void turnright_right(int right) {
	motor[rightfrontwheel] = right;
	motor[rightbackwheel] = right;
}
void turnright(int right) {
	turnright_right(right);
	turnright_left(right);
}
void turnLeftWithSensor(int rotations) {
	SensorValue[in1] = 0;
	int min_rightpower = 38.5;
	int min_leftpower = 38.5;
	int leftmultiplier = 1;
	int rightmultiplier = -1;
	while(abs(SensorValue[in1]) < rotations)
	{
				int leftpower = 0;
		int rightpower = 0;

		int error = rotations - abs(SensorValue[in1]);
			leftpower = error * P_FACTOR;
			rightpower = error * P_FACTOR;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(TURN_MAXPOWER, leftpower);

		if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(TURN_MAXPOWER, rightpower);

			turnleft_left(leftpower * leftmultiplier);
		turnleft_right(rightpower * rightmultiplier);
	//	wait1Msec(MOTOR_TASK_DELAY);
	}
		turnleft(0);
	wait1Msec(WAIT_FOR_STOP);
		}
		void turnRightWithSensor(int rotations) {
	SensorValue[in1] = 0;
	int min_rightpower = 38.5;
	int min_leftpower = 38.5;
	int leftmultiplier = -1;
	int rightmultiplier = 1;
	while(abs(SensorValue[in1]) < rotations)
	{
				int leftpower = 0;
		int rightpower = 0;

		int error = rotations - abs(SensorValue[in1]);
			leftpower = error * P_FACTOR;
			rightpower = error * P_FACTOR;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(TURN_MAXPOWER, leftpower);

		if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(TURN_MAXPOWER, rightpower);

			turnright_left(leftpower * leftmultiplier);
		turnright_right(rightpower * rightmultiplier);
	//	wait1Msec(MOTOR_TASK_DELAY);
	}
		turnleft(0);
	wait1Msec(WAIT_FOR_STOP);
		}

void moveBackwardWithSensor(int rotations) {
	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueLeft = 0;
	int lastSensorValueRight = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	float slowdown = .98;
	int buffer = 20;
	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET) {
		int leftpower = 0;
		int rightpower = 0;
		if (abs(SensorValue[leftshaft]) < rotations) {

			int error = rotations - abs(SensorValue[leftshaft]);

			leftpower = error * P_FACTOR;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(MAXPOWER, leftpower);
		}
		if (abs(SensorValue[rightshaft]) < rotations) {

			int error = rotations - abs(SensorValue[rightshaft]);

			rightpower = error * P_FACTOR ;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(MAXPOWER, rightpower);
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}
		movebackward_left(leftpower * leftmultiplier);
		movebackward_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
	//	wait1Msec(MOTOR_TASK_DELAY);
	}
	movebackward(0);

	wait1Msec(WAIT_FOR_STOP);
}
void moveForwardWithSensor(int rotations) {

	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueRight = 0;
	int lastSensorValueLeft = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	int buffer = 20;
	float slowdown = .98;





	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET)	 {
		int leftpower = 0;
		int rightpower = 0;

		if (abs(SensorValue[leftshaft]) < rotations) {

			int error = rotations - SensorValue[leftshaft];

			leftpower = error * P_FACTOR;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(MAXPOWER, leftpower);
		}
		if (abs(SensorValue[rightshaft]) < rotations) {

			int error = rotations - SensorValue[rightshaft];

			rightpower = error * P_FACTOR;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
	rightpower = min(MAXPOWER, rightpower);

		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}

		moveforward_left(leftpower * leftmultiplier);
		moveforward_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
//		wait1Msec(MOTOR_TASK_DELAY);
	}
	moveforward(0);
//	wait1Msec(WAIT_FOR_STOP);
}
#include "RedAuto.c"

task autonomous()
{
	LCDAutonomous();

  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  RedAuto();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  startTask(MotorSlewRateTask);
	startTask(ScissorControl);
	startTask(FourBarControl);
//ScissorLiftControl = false;
	FourControl = true;
	while(true)
	{
    LCDUserControl();
		int RightDrive = 0;
		int LeftDrive = 0;
		if(abs(vexRT[Ch2])>DEADBAND)
		{
			LeftDrive = vexRT[Ch2];
			RightDrive = vexRT[Ch2];
		}
		else if (abs(vexRT[Ch4])>DEADBAND)
		{
			LeftDrive = vexRT[Ch4];
			RightDrive = -vexRT[Ch4];
		}

 if (ScissorLiftControl)
 {
		if (vexRT[Btn8UXmtr2] == 1)
		{
			Scissortarget = min(MAX_SCISSORHEIGHT, Scissortarget + 10); //Decreased from 30 to 1, the loop is execute many times per seconds, so the value was changing too fast
			ScissorLiftControl = true;
		}
		else if(vexRT[Btn8DXmtr2] == 1)
		{
			Scissortarget = max(MIN_SCISSORHEIGHT, Scissortarget - 10);
			ScissorLiftControl = true;
		}
	}
	else
	{
		if (vexRT[Btn8UXmtr2] == 1)
		{
			motorReq[RightLift] = 127;
			motorReq[LeftLift] = 127;
		}
		else if (vexRT[Btn8DXmtr2] == 1)
		{
			motorReq[RightLift] = -50;
			motorReq[LeftLift] = -50;
		}
		else
		{
			motorReq[RightLift] = 0;
			motorReq[LeftLift] = 0;
		}
 }

		if(vexRT[Btn7UXmtr2] == 1)
		{
			motor[FourBar] = 127;
		}
		else if(vexRT[Btn7DXmtr2] == 1)
		{
			motor[FourBar] = -127;
		}
		else
		{
			motor[FourBar] = 0;
		}
		if(vexRT[Btn5UXmtr2] == 1)
		{
			motor[ConeIntake] = 127;
		}
		else if(vexRT[Btn5DXmtr2] == 1)
		{
			motor[ConeIntake] = -127;
		}
		else
		{
			motor[ConeIntake] =0;
		}

if(vexRT[Btn6U] == 1)
{
	ScissorLiftControl = true;
}
else if(vexRT[Btn6D] == 1)
{
	ScissorLiftControl = false;
}


   if(vexRT[Btn5U] == 1)
   {
      RedAuto();
   }  // 7^3
   if(vexRT[Btn7U] == 1)
   {
     motor[Mogo] = 127;

   }
   else if(vexRT[Btn7D] == 1)
   {
     motor[Mogo] = -127;
   }
   else motor[Mogo] = 0;



  motor(leftfrontwheel) = LeftDrive;
  motor(leftbackwheel) = LeftDrive;
  motor(rightfrontwheel) = RightDrive;
  motor(rightbackwheel) = RightDrive;
   wait1Msec(MOTOR_TASK_DELAY);
	}
}
