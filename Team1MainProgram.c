#pragma config(Sensor, in1,    Gyroscope,      sensorGyro)
#pragma config(Sensor, in2,    RightLiftSensor, sensorPotentiometer)
#pragma config(Sensor, in3,    LeftLiftSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightshaft,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftshaft,      sensorQuadEncoder)
#pragma config(Motor,  port2,           rightbackwheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightfrontwheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           FourBar,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LeftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftbackwheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftfrontwheel, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

 #include "slew motor program.c"

#define DEADBAND 20
void testauto();




const int MAX_SCISSORHEIGHT = 4100;
const int MIN_SCISSORHEIGHT = 0;
const int TURNRIGHT_90 = 250;
const int TURNLEFT_90 = 250;
const float SLEW_OFFSET = .8;
const int MAXPOWER = 90;
const int TURN_MAXPOWER = 80;
const float P_FACTOR = .2;
const int WAIT_FOR_STOP = 200;
int Scissortarget = 0;
bool ScissorLiftControl = false;


int min(int a, int b) {
	if (a > b)
		return b;
	return a;
}

int max(int a, int b) {
	if (a > b)
		return a;
	return b;
}
task ScissorControl()
{
	int ScissorerrorRight = 0;
  int ScissorerrorLeft = 0;
  int ScissorLiftLeft = 0;
  int ScissorLiftRight = 0;
  int buffer = 100;
	while (true) {
		if(ScissorLiftControl)
		{
		/*	if (Scissortarget < 12341234123412341234123412341234123412341243123412341234)
			{
				Scissortarget = Scissortarget;
			}
			if(Scissortarget > 123412341234123412341234)
			{
				Scissortarget = Scissortarget;
			}*/
			int currentvalueRight = SensorValue[RightliftSensor];
			ScissorerrorRight = Scissortarget - abs(currentvalueRight);
			ScissorLiftRight = ScissorerrorRight
			if (abs(ScissorLiftRight) > 127) {
				ScissorLiftRight = 127;
			}
			if (abs(ScissorLiftRight) < 20)
				ScissorLiftRight = 0;


		int currentvalueLeft = SensorValue[LeftLiftSensor];
		scissorerrorLeft = Scissortarget - abs(currentvalueLeft);
		ScissorLiftLeft = ScissorerrorLeft
					if (abs(ScissorLiftLeft) > 127) {
				ScissorLiftLeft = 127;
			}
			if (abs(ScissorLiftLeft) < 20)
				ScissorLiftLeft = 0;



		//Sensors Moving to fast
				if (abs(SensorValue[LeftLiftSensor]) > abs(SensorValue[RightLiftSensor]) + buffer)
				{
					ScissorLiftLeft -= 5;
				}
				else if (abs(SensorValue[LeftLiftSensor]) < abs(SensorValue[RightLiftSensor]) + buffer)
			{
				ScissorLiftLeft += 5;
			}
			// Right Sensor moving too fast
			if (abs(SensorValue[RightLiftSensor]) > abs(SensorValue[LeftLiftSensor]) + buffer)
			{
				ScissorLiftRight -= 5;
			}
			if (abs(SensorValue[RightLiftSensor}) < abs(SensorValue[LeftLiftSensor]) + buffer)
			{
				ScissorLiftRight += 5;
			}

			motorReq[rightlift] = ScissorLiftRight;
			motorReq[leftlift] = ScissorLiftLeft;
		}
		wait1Msec(MOTOR_TASK_DELAY);
	}
}


	void moveforward_right(int forward) {

	motor[rightfrontwheel] = -forward;
	motor[rightbackwheel] = -forward;
}
void moveforward_left(int forward) {
	motor[leftfrontwheel] = forward;
	motor[leftbackwheel] = forward;
}
void moveforward(int forward) {
	moveforward_left(forward);
	moveforward_right(forward);
}
void movebackward_left(int backward) {
	motor[leftfrontwheel] = -backward;
	motor[leftbackwheel] = -backward;
}
void movebackward_right(int backward) {
	motor[rightfrontwheel] = backward;
	motor[rightbackwheel] = backward;
}
void movebackward(int backward) {
	movebackward_right(backward);
	movebackward_left(backward);
}
void turnleft_left(int left) {
	motor[leftfrontwheel] = -left;
	motor[leftbackwheel] = -left;
}
void turnleft_right(int left) {
	motor[rightfrontwheel] = -left;
	motor[rightbackwheel] = -left;
}
void turnleft(int left) {
	turnleft_right(left);
	turnleft_left(left);
}
void turnright_left(int right) {
	motor[leftfrontwheel] = right;
	motor[leftbackwheel] = right;
}
void turnright_right(int right) {
	motor[rightfrontwheel] = right;
	motor[rightbackwheel] = right;
}
void turnright(int right) {
	turnright_right(right);
	turnright_left(right);
}
void turnLeftWithSensor(int rotations) {
	SensorValue[in1] = 0;
	int min_rightpower = 28.5;
	int min_leftpower = 28.5;
	int leftmultiplier = 1;
	int rightmultiplier = -1;
	while(abs(SensorValue[in1]) < rotations)
	{
				int leftpower = 0;
		int rightpower = 0;

		int error = rotations - abs(SensorValue[in1]);
			leftpower = error * P_FACTOR;
			rightpower = error * P_FACTOR;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(TURN_MAXPOWER, leftpower);

		if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(TURN_MAXPOWER, rightpower);

			turnleft_left(leftpower * leftmultiplier);
		turnleft_right(rightpower * rightmultiplier);
	//	wait1Msec(MOTOR_TASK_DELAY);
	}
		turnleft(0);
	wait1Msec(WAIT_FOR_STOP);
		}
		void turnRightWithSensor(int rotations) {
	SensorValue[in1] = 0;
	int min_rightpower = 28.5;
	int min_leftpower = 28.5;
	int leftmultiplier = -1;
	int rightmultiplier = 1;
	while(abs(SensorValue[in1]) < rotations)
	{
				int leftpower = 0;
		int rightpower = 0;

		int error = rotations - abs(SensorValue[in1]);
			leftpower = error * P_FACTOR;
			rightpower = error * P_FACTOR;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(TURN_MAXPOWER, leftpower);

		if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(TURN_MAXPOWER, rightpower);

			turnright_left(leftpower * leftmultiplier);
		turnright_right(rightpower * rightmultiplier);
	//	wait1Msec(MOTOR_TASK_DELAY);
	}
		turnleft(0);
	wait1Msec(WAIT_FOR_STOP);
		}

void moveBackwardWithSensor(int rotations) {
	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueLeft = 0;
	int lastSensorValueRight = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	float slowdown = .98;
	int buffer = 20;
	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET) {
		int leftpower = 0;
		int rightpower = 0;
		if (abs(SensorValue[leftshaft]) < rotations) {

			int error = rotations - abs(SensorValue[leftshaft]);

			leftpower = error * P_FACTOR;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(MAXPOWER, leftpower);
		}
		if (abs(SensorValue[rightshaft]) < rotations) {

			int error = rotations - abs(SensorValue[rightshaft]);

			rightpower = error * P_FACTOR ;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(MAXPOWER, rightpower);
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}
		movebackward_left(leftpower * leftmultiplier);
		movebackward_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
	//	wait1Msec(MOTOR_TASK_DELAY);
	}
	movebackward(0);

	wait1Msec(WAIT_FOR_STOP);
}
void moveForwardWithSensor(int rotations) {

	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueRight = 0;
	int lastSensorValueLeft = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	int buffer = 20;
	float slowdown = .98;





	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET)	 {
		int leftpower = 0;
		int rightpower = 0;

		if (SensorValue[leftshaft] < rotations) {

			int error = rotations - SensorValue[leftshaft];

			leftpower = error * P_FACTOR;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(MAXPOWER, leftpower);
		}
		if (SensorValue[rightshaft] < rotations) {

			int error = rotations - SensorValue[rightshaft];

			rightpower = error * P_FACTOR;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(MAXPOWER, rightpower);
			\
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}

		moveforward_left(leftpower * leftmultiplier);
		moveforward_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
//		wait1Msec(MOTOR_TASK_DELAY);
	}
	moveforward(0);
//	wait1Msec(WAIT_FOR_STOP);
}
task main()
{
	startTask(MotorSlewRateTask);
	startTask(ScissorControl);
	ScissorLiftControl = true;
	while(true)
	{

		int RightDrive = 0;
		int LeftDrive = 0;
		if(abs(vexRT[Ch2])>DEADBAND)
		{
			LeftDrive = vexRT[Ch2];
			RightDrive = vexRT[Ch2];
		}
		else if (abs(vexRT[Ch4])>DEADBAND)
		{
			LeftDrive = vexRT[Ch4];
			RightDrive = -vexRT[Ch4];
		}


		if (vexRT[Btn8UXmtr2] == 1)
		{
			Scissortarget = min(MAX_SCISSORHEIGHT, Scissortarget + 30);
			ScissorLiftControl = true;
		}
		else if(vexRT[Btn8DXmtr2] == 1)
		{
			Scissortarget = max(MIN_SCISSORHEIGHT, Scissortarget - 30);
			ScissorLiftControl = true;
		}
		else
		{
			motor[RightLift] = 0;
			motor[LeftLift] = 0;
		}


		if(vexRT[Btn7UXmtr2] == 1)
		{
			motor[FourBar] = 127;
		}
		else if(vexRT[Btn7DXmtr2] == 1)
		{
			motor[FourBar] = -127;
		}
		else
		{
			motor[FourBar] = 0;
		}



   if(vexRT[Btn5U] == 1)
   {
     turnLeftWithSensor(900);
   }  // 7^3
   if(vexRT[Btn7U] == 1)
   {
     motor[Mogo] = 127;

   }
   else if(vexRT[Btn7D] == 1)
   {
     motor[Mogo] = -127;
   }
   else motor[Mogo] = 0;



  motor(leftfrontwheel) = LeftDrive;
  motor(leftbackwheel) = LeftDrive;
  motor(rightfrontwheel) = RightDrive;
  motor(rightbackwheel) = RightDrive;
  // wait1Msec(MOTOR_TASK_DELAY);
	}
}
