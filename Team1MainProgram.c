#pragma config(Sensor, dgtl1,  rightshaft,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftshaft,      sensorQuadEncoder)
#pragma config(Motor,  port2,           rightbackwheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightfrontwheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftbackwheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftfrontwheel, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "slew motor program.c"

#define DEADBAND 20





const int CLAW_CLOSE = 1000;
const int CLAW_OPEN = 1600;
const int CLAW_OPEN_WIDE = 2600;
const int ARM_HIGH = 2650;
const int TURNRIGHT_90 = 250;
const int TURNLEFT_90 = 250;
const float SLEW_OFFSET = .8;
const int MAXPOWER = 90;
const int TURN_MAXPOWER = 60;
const float P_FACTOR = .2;
const int WAIT_FOR_STOP = 200;
const int MAX_CLAW = 3900;

const int HIGHFENCE = 2400;
const int LOWFENCE = 2100;




int min(int a, int b) {
	if (a > b)
		return b;
	return a;
}

int max(int a, int b) {
	if (a > b)
		return a;
	return b;
}

	void moveforward_right(int forward) {

	motor[rightfrontwheel] = -forward;
	motor[rightbackwheel] = -forward;
}
void moveforward_left(int forward) {
	motor[leftfrontwheel] = forward;
	motor[leftbackwheel] = forward;
}
void moveforward(int forward) {
	moveforward_left(forward);
	moveforward_right(forward);
}
void movebackward_left(int backward) {
	motor[leftfrontwheel] = -backward;
	motor[leftbackwheel] = -backward;
}
void movebackward_right(int backward) {
	motor[rightfrontwheel] = backward;
	motor[rightbackwheel] = backward;
}
void movebackward(int backward) {
	movebackward_right(backward);
	movebackward_left(backward);
}
void turnleft_left(int left) {
	motor[leftfrontwheel] = -left;
	motor[leftbackwheel] = -left;
}
void turnleft_right(int left) {
	motor[rightfrontwheel] = -left;
	motor[rightbackwheel] = -left;
}
void turnleft(int left) {
	turnleft_right(left);
	turnleft_left(left);
}
void turnright_left(int right) {
	motor[leftfrontwheel] = right;
	motor[leftbackwheel] = right;
}
void turnright_right(int right) {
	motor[rightfrontwheel] = right;
	motor[rightbackwheel] = right;
}
void turnright(int right) {
	turnright_right(right);
	turnright_left(right);
}

task main()
{
	while(true)
	{
		startTask(MotorSlewRateTask);
		int RightDrive = 0;
		int LeftDrive = 0;
		if(abs(vexRT[Ch2])>DEADBAND)
		{
			LeftDrive = vexRT[Ch2];
			RightDrive = vexRT[Ch2];
		}
		else if (abs(vexRT[Ch4])>DEADBAND)
		{
			LeftDrive = vexRT[Ch4];
			RightDrive = -vexRT[Ch4];
		}


  motor(leftfrontwheel) = LeftDrive;
  motor(leftbackwheel) = LeftDrive;
  motor(rightfrontwheel) = RightDrive;
  motor(rightbackwheel) = RightDrive;
	}
}
void moveForwardWithSensor(int rotations) {

	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueRight = 0;
	int lastSensorValueLeft = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	int buffer = 20;
	float slowdown = .98;





	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET)	 {
		int leftpower = 0;
		int rightpower = 0;

		if (SensorValue[leftshaft] < rotations) {

			int error = rotations - SensorValue[leftshaft];

			leftpower = error * P_FACTOR;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(MAXPOWER, leftpower);
		}
		if (SensorValue[rightshaft] < rotations) {

			int error = rotations - SensorValue[rightshaft];

			rightpower = error * P_FACTOR;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(MAXPOWER, rightpower);
			\
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}

		moveforward_left(leftpower * leftmultiplier);
		moveforward_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
		wait1Msec(MOTOR_TASK_DELAY);
	}
	moveforward(0);
	wait1Msec(WAIT_FOR_STOP);
}
